import logging

from config import OPERATOR_ID, DIR_FOR_COMMERCIAL_OFFERS, DIR_FOR_TECHNICAL_TASKS, DIR_FOR_OTHER_FILES, \
    DIR_FOR_REPORTS, DIR_FOR_SAVE_DIALOGS
from handlers.keyboards import ClientKeyboards, OperatorKeyboards, GeneralKeyboards
from handlers.documents import send_document_to_telegram
from services.db_data import get_question_and_answers_from_db, \
    get_user_answer, get_user_data_from_db, get_sections_from_db, get_sub_directions
from services.file_handler import find_user_documents, file_check, get_list_of_clients_dialogue_files
from services.redis_db import redis_cache
from services.states import MyStates, OperatorStates
from handlers.text_messages import TEXT_MESSAGES
from services.string_parser import CallDataParser

logger = logging.getLogger(__name__)


class BaseCallbackHandlers:
    @staticmethod
    def briefing(call, bot):
        bot.edit_message_text(chat_id=call.message.chat.id,
                              message_id=call.message.message_id,
                              text=TEXT_MESSAGES['menu'], reply_markup=GeneralKeyboards.directions())

    @staticmethod
    def directory(call, bot):
        direction = call.data
        list_of_sub_directions = get_sub_directions(direction)
        if list_of_sub_directions:
            keyboard = GeneralKeyboards.sub_directions(direction, list_of_sub_directions)
        else:
            list_of_sections = get_sections_from_db(direction)
            keyboard = GeneralKeyboards.sections(direction, list_of_sections)
        bot.edit_message_text(chat_id=call.message.chat.id,
                              message_id=call.message.message_id,
                              text=TEXT_MESSAGES['menu'],
                              reply_markup=keyboard)

    @staticmethod
    def sub_directory(call, bot):
        path = call.data
        bot.edit_message_text(chat_id=call.message.chat.id,
                              message_id=call.message.message_id,
                              text=TEXT_MESSAGES['menu'],
                              reply_markup=GeneralKeyboards.sections_from_subcategory(path))

    @staticmethod
    def section(call, bot):
        path = call.data
        keyboard = OperatorKeyboards.questions(call.from_user.id, path)
        if call.from_user.id != OPERATOR_ID:
            keyboard = ClientKeyboards.questions(call.from_user.id, path)
        bot.edit_message_text(chat_id=call.message.chat.id,
                              message_id=call.message.message_id,
                              text=TEXT_MESSAGES['menu'],
                              reply_markup=keyboard)

    @staticmethod
    def cancel_to_directions(call, bot):
        bot.edit_message_text(chat_id=call.message.chat.id,
                              message_id=call.message.message_id,
                              text=TEXT_MESSAGES['menu'],
                              reply_markup=GeneralKeyboards.directions())

    @staticmethod
    def back_to_questions(call, bot):
        path = redis_cache.get_keyboard_for_questions(call.from_user.id)
        bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id,
                              text=TEXT_MESSAGES['menu'],
                              reply_markup=ClientKeyboards.questions(call.from_user.id, path))


class ClientCallbackHandlers:

    @staticmethod
    def file_types(call, bot):
        bot.edit_message_text(chat_id=call.message.chat.id,
                              message_id=call.message.message_id,
                              text='–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø —Ñ–∞–π–ª–∞',
                              reply_markup=ClientKeyboards.types_of_files())

    @staticmethod
    def __show_files_for_client(call, bot, directory):
        user_id = call.from_user.id
        logger.info(f'–ö–ª–∏–µ–Ω—Ç {user_id} –∑–∞–ø—Ä–æ—Å–∏–ª —Ñ–∞–π–ª—ã')
        dict_path_to_files = find_user_documents(user_id, directory)
        redis_cache.set_selected_directory(call.from_user.id, directory)
        if not dict_path_to_files:
            text = '–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é —É –≤–∞—Å –Ω–µ—Ç –æ—Ñ–æ—Ä–º–ª–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤'
        else:
            redis_cache.save_dict_of_path_for_download_file(user_id, dict_path_to_files)
            text = '–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞–∫–æ–π —Ñ–∞–π–ª –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ–ª—É—á–∏—Ç—å:'
        bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id,
                              text=text, reply_markup=ClientKeyboards.files(dict_path_to_files))

    @staticmethod
    def technical_tasks(call, bot):
        ClientCallbackHandlers.__show_files_for_client(call, bot, DIR_FOR_TECHNICAL_TASKS)

    @staticmethod
    def commercial_offer(call, bot):
        ClientCallbackHandlers.__show_files_for_client(call, bot, DIR_FOR_COMMERCIAL_OFFERS)

    @staticmethod
    def reports(call, bot):
        ClientCallbackHandlers.__show_files_for_client(call, bot, DIR_FOR_REPORTS)

    @staticmethod
    def documents(call, bot):
        ClientCallbackHandlers.__show_files_for_client(call, bot, DIR_FOR_OTHER_FILES)

    @staticmethod
    def chat_with_operator(call, bot):
        bot.send_contact(call.message.chat.id, phone_number='+74950188868', first_name='–û–ø–µ—Ä–∞—Ç–æ—Ä Mr.–≠–π—á')
        bot.send_message(call.message.chat.id, TEXT_MESSAGES['chat_with_operator'])

    @staticmethod
    def blog(call, bot):
        pass

    @staticmethod
    def enter_menu(call, bot):
        client_id = call.from_user.id
        user_data = get_user_data_from_db(client_id)
        reply_markup = ClientKeyboards.enter_menu(doc=False)
        if user_data['documents']:
            reply_markup = ClientKeyboards.enter_menu(doc=True)
        bot.edit_message_text(chat_id=call.message.chat.id,
                              message_id=call.message.message_id,
                              text=TEXT_MESSAGES['start'].format(username=user_data['name'],
                                                                 company=user_data['company']),
                              reply_markup=reply_markup)

    @staticmethod
    def change_answer(call, bot):
        bot.delete_message(call.message.chat.id, call.message.id)
        bot.set_state(call.from_user.id, MyStates.answer_to_question, call.from_user.id)
        question_id = redis_cache.get_question_id(call.from_user.id)
        question, answers = get_question_and_answers_from_db(question_id)
        bot.send_message(call.message.chat.id, f'‚ùì{question}?\n\n–ù–∞–ø–∏—à–∏—Ç–µ –æ—Ç–≤–µ—Ç –∏ –Ω–∞–∂–º–∏—Ç–µ "‚úÖ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç–≤–µ—Ç"',
                         reply_markup=ClientKeyboards.answer(answers))

    @staticmethod
    def questions(call, bot):
        question_id = CallDataParser.get_question_id(call.data)
        if question_id <= redis_cache.get_max_question_id(call.from_user.id):
            next_callback = f"question|{question_id + 1}"
            redis_cache.set_question_id(user=call.from_user.id, question_id=question_id)
            redis_cache.set_next_question_callback(user=call.from_user.id, callback=next_callback)
        question, answers = get_question_and_answers_from_db(question_id)
        user_answer = get_user_answer(call.from_user.id, question_id)
        if user_answer:
            bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id,
                                  text=f'‚ùì{question}?\n\n–í–∞—à –æ—Ç–≤–µ—Ç:{user_answer}',
                                  reply_markup=ClientKeyboards.change_answer())
            return
        bot.set_state(call.from_user.id, MyStates.answer_to_question, call.from_user.id)
        bot.delete_message(call.message.chat.id, call.message.id)
        bot.send_message(call.message.chat.id, f'‚ùì{question}?\n\n–ù–∞–ø–∏—à–∏—Ç–µ –æ—Ç–≤–µ—Ç –∏ –Ω–∞–∂–º–∏—Ç–µ "‚úÖ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç–≤–µ—Ç"',
                         reply_markup=ClientKeyboards.answer(answers))

    @staticmethod
    def grade(call, bot):
        bot.delete_message(call.message.chat.id, call.message.id)
        match call.data:
            case 'client_grade_yes':
                user_data = get_user_data_from_db(call.from_user.id)
                path_to_file = redis_cache.get_last_file_path(call.from_user.id)
                caption = f"–¢–µ—Ö–Ω–∏—á–µ—Å–∫–æ–µ –∑–∞–¥–∞–Ω–∏–µ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:\n{user_data['name']}\n" \
                          f"Username: {user_data['tg_username']}\n" \
                          f"–ö–æ–º–ø–∞–Ω–∏—è: {user_data['company']}\n" \
                          f"–¢–µ–ª–µ—Ñ–æ–Ω: {user_data['phone']}\n" \
                          f"Website: {user_data['website']}\n"
                visible_file_name = f'–¢–µ—Ö.–∑–∞–¥–∞–Ω–∏–µ –∫–æ–º–ø–∞–Ω–∏–∏ {user_data["company"]}.docx'
                send_document_to_telegram(bot, OPERATOR_ID, path_to_file, caption=caption,
                                          visible_file_name=visible_file_name)
                redis_cache.add_client_to_queue(call.from_user.id)
                bot.send_message(OPERATOR_ID, '–ù–∞—á–∞—Ç—å —á–∞—Ç —Å –∫–ª–∏–µ–Ω—Ç–æ–º ?',
                                 reply_markup=OperatorKeyboards.customer_information(call.from_user.id))
            case 'client_grade_no':
                bot.send_message(call.message.chat.id, f'–•–æ—Ä–æ—à–æ, –æ—Ç–ª–∏—á–Ω–æ–≥–æ –¥–Ω—è!')

    # –î–∏–∞–ª–æ–≥ —Å –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–º
    @staticmethod
    def instant_messaging_service(call, bot):
        client_id = call.from_user.id
        user_data = get_user_data_from_db(client_id)
        operator_state = redis_cache.get_operator_state()
        logger.info(f'–ó–∞–ø—Ä–æ—Å –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞ {client_id} –Ω–∞ –¥–∏–∞–ª–æ–≥')
        match operator_state:
            case b'free' | None:
                redis_cache.set_operator_state(b'busy')
                logger.info(f'–ü–µ—Ä–µ–≤–æ–¥ —Å—Ç–∞—Ç—É—Å–∞ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ –≤ "–∑–∞–Ω—è—Ç" (busy)')
                bot.send_message(OPERATOR_ID, f'üí¨–ó–∞–ø—Ä–æ—Å –Ω–∞ –¥–∏–∞–ª–æ–≥!üß®\n\n–ö–ª–∏–µ–Ω—Ç: {user_data["name"]}\n'
                                              f'–ö–æ–º–ø–∞–Ω–∏—è: {user_data["company"]}\n'
                                              f'–¢–µ–ª–µ—Ñ–æ–Ω: {user_data["phone"]}',
                                 reply_markup=OperatorKeyboards.customer_information(client_id))
            case _:
                logger.info(f'–û–ø–µ—Ä–∞—Ç–æ—Ä –∑–∞–Ω—è—Ç')
        match redis_cache.add_client_to_queue(client_id):
            case True:
                logger.info(f'–ö–ª–∏–µ–Ω—Ç {client_id} –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –≤ –æ—á–µ—Ä–µ–¥–∏ –∏ –∂–¥–µ—Ç –æ—Ç–≤–µ—Ç–∞ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞')
                bot.send_message(call.message.chat.id, '–ü–æ–¥–æ–∂–¥–∏—Ç–µ –ø–æ–∫–∞ –æ–ø–µ—Ä–∞—Ç–æ—Ä –∫ –≤–∞–º –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—Å—è...')
            case _:
                logger.info(f'–ö–ª–∏–µ–Ω—Ç {client_id} —É–∂–µ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ –æ—á–µ—Ä–µ–¥–∏')
                bot.send_message(call.message.chat.id,
                                 '–í—ã —É–∂–µ –≤ –æ—á–µ—Ä–µ–¥–∏ –ø–æ–¥–æ–∂–¥–∏—Ç–µ –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–∫–∞ –æ–ø–µ—Ä–∞—Ç–æ—Äüë® –æ—Ç–≤–µ—Ç–∏—Ç –≤–∞–º ‚Äçüíªüòä')
                bot.send_message(OPERATOR_ID,
                                 f'‚ùóÔ∏è–ù–µ –∑–∞–±—ã–≤–∞–π—Ç–µ –æ –∫–ª–∏–µ–Ω—Ç–µ\n'
                                 f'–û–Ω –ø–æ–≤—Ç–æ—Ä–Ω–æ –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç –¥–∏–∞–ª–æ–≥\n\n'
                                 f'–ö–ª–∏–µ–Ω—Ç: {user_data["name"]}\n'
                                 f'–ö–æ–º–ø–∞–Ω–∏—è: {user_data["company"]}\n'
                                 f'–¢–µ–ª–µ—Ñ–æ–Ω: {user_data["phone"]}\n\n'
                                 f'–ú–µ–Ω—é(/start) -> –ó–∞–ø—Ä–æ—Å—ã'
                                 )


class OperatorCallbackHandlers(BaseCallbackHandlers):
    @staticmethod
    def requests(call, bot):
        queue_of_clients = redis_cache.get_queue_of_clients()
        text = '–ó–∞–ø—Ä–æ—Å—ã –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π'
        if not queue_of_clients:
            text = '–ó–∞–ø—Ä–æ—Å–æ–≤ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –Ω–µ—Ç'
        callback_data_prefix = 'queue'
        bot.edit_message_text(chat_id=call.message.chat.id,
                              message_id=call.message.message_id,
                              text=text, reply_markup=OperatorKeyboards.clients(queue_of_clients, callback_data_prefix))

    @staticmethod
    def clients(call, bot):
        list_of_clients = get_list_of_clients_dialogue_files()
        text = '–í—ã–±–µ—Ä–∏—Ç–µ –∫–ª–∏–µ–Ω—Ç–∞:'
        callback_data_prefix = 'client|info'
        if not list_of_clients:
            text = '–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–∏–∞–ª–æ–≥–æ–≤ —Å –∫–ª–∏–µ–Ω—Ç–∞–º'
        bot.edit_message_text(chat_id=call.message.chat.id,
                              message_id=call.message.message_id,
                              text=text, reply_markup=OperatorKeyboards.clients(list_of_clients, callback_data_prefix))

    @staticmethod
    def tasks(call, bot):
        pass

    @staticmethod
    def settings(call, bot):
        bot.edit_message_text(chat_id=call.message.chat.id,
                              message_id=call.message.message_id,
                              text='–ó–¥–µ—Å—å –≤—ã –º–æ–∂–µ—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å –∏–ª–∏ –¥–æ–±–∞–≤–∏—Ç—å –≤–æ–ø—Ä–æ—Å—ã, —Å–µ–∫—Ü–∏–∏ –∏ —Ä–∞–∑–¥–µ–ª—ã',
                              reply_markup=OperatorKeyboards.settings())

    @staticmethod
    def enter_menu(call, bot):
        bot.edit_message_text(chat_id=call.message.chat.id,
                              message_id=call.message.message_id,
                              text=TEXT_MESSAGES['start_for_operator'], reply_markup=OperatorKeyboards.enter_menu())

    @staticmethod
    def get_dialogue_history(call, bot):
        client_id = CallDataParser.get_client_id(call.data)
        path_to_dialogue_file = f'{DIR_FOR_SAVE_DIALOGS}/{client_id}/dialogue.log'
        if file_check(path_to_dialogue_file):
            send_document_to_telegram(bot, call.from_user.id, path_to_dialogue_file, caption='–ò—Å—Ç–æ—Ä–∏—è –¥–∏–∞–ª–æ–≥–∞',
                                      visible_file_name='–î–∏–∞–ª–æ–≥.log')
        else:
            bot.send_message(call.from_user.id, '–ò—Å—Ç–æ—Ä–∏—è –¥–∏–∞–ª–æ–≥–∞ –ø—É—Å—Ç–∞')

    @staticmethod
    def file_types(call, bot):
        client_id = CallDataParser.get_client_id(call.data)
        bot.edit_message_text(chat_id=call.message.chat.id,
                              message_id=call.message.message_id, text='–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª',
                              reply_markup=OperatorKeyboards.types_documents(client_id))

    @staticmethod
    def __show_client_files_in_dialogue(call, bot, dir_path, client_id):
        if client_id is None:
            bot.delete_message(call.message.chat.id, call.message.id)
            return
        dict_path_to_files = find_user_documents(client_id, dir_path)
        redis_cache.set_selected_directory(call.from_user.id, dir_path)
        if not dict_path_to_files:
            text = f'–ù–µ—Ç –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ —É –∫–ª–∏–µ–Ω—Ç–∞'
        else:
            redis_cache.save_dict_of_path_for_download_file(client_id, dict_path_to_files)
            text = '–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞–∫–æ–π —Ñ–∞–π–ª –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ–ª—É—á–∏—Ç—å:'
        bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id, text=text,
                              reply_markup=OperatorKeyboards.client_files(dict_path_to_files, in_dialogue=True))

    @staticmethod
    def technical_tasks_in_dialogue(call, bot):
        user_id = redis_cache.get_first_client_from_queue()
        OperatorCallbackHandlers.__show_client_files_in_dialogue(call, bot, DIR_FOR_TECHNICAL_TASKS, user_id)

    @staticmethod
    def commercial_offers_in_dialogue(call, bot):
        user_id = redis_cache.get_first_client_from_queue()
        OperatorCallbackHandlers.__show_client_files_in_dialogue(call, bot, DIR_FOR_COMMERCIAL_OFFERS, user_id)

    @staticmethod
    def reports_in_dialogue(call, bot):
        user_id = redis_cache.get_first_client_from_queue()
        OperatorCallbackHandlers.__show_client_files_in_dialogue(call, bot, DIR_FOR_REPORTS, user_id)

    @staticmethod
    def other_documents_in_dialogue(call, bot):
        user_id = redis_cache.get_first_client_from_queue()
        OperatorCallbackHandlers.__show_client_files_in_dialogue(call, bot, DIR_FOR_OTHER_FILES, user_id)

    @staticmethod
    def __show_client_files(call, bot, dir_path, client_id):
        logger.info(f'–ó–∞–ø—Ä–æ—Å —Ñ–∞–π–ª–æ–≤ –∫–ª–∏–µ–Ω—Ç–∞: {client_id}')
        dict_path_to_files = find_user_documents(client_id, dir_path)
        redis_cache.set_selected_directory(call.from_user.id, dir_path)
        redis_cache.set_user_to_display_information(client_id)
        if not dict_path_to_files:
            text = f'–ù–µ—Ç –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ —É –∫–ª–∏–µ–Ω—Ç–∞'
        else:
            redis_cache.save_dict_of_path_for_download_file(client_id, dict_path_to_files)
            text = '–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞–∫–æ–π —Ñ–∞–π–ª –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ–ª—É—á–∏—Ç—å:'
        bot.edit_message_text(chat_id=call.message.chat.id, message_id=call.message.message_id, text=text,
                              reply_markup=OperatorKeyboards.client_files(dict_path_to_files))

    @staticmethod
    def client_technical_tasks(call, bot):
        client_id = CallDataParser.get_client_id(call.data)
        OperatorCallbackHandlers.__show_client_files(call, bot, DIR_FOR_TECHNICAL_TASKS, client_id)

    @staticmethod
    def client_commercial_offers(call, bot):
        client_id = CallDataParser.get_client_id(call.data)
        OperatorCallbackHandlers.__show_client_files(call, bot, DIR_FOR_COMMERCIAL_OFFERS, client_id)

    @staticmethod
    def client_reports(call, bot):
        client_id = CallDataParser.get_client_id(call.data)
        OperatorCallbackHandlers.__show_client_files(call, bot, DIR_FOR_REPORTS, client_id)

    @staticmethod
    def client_other_documents(call, bot):
        client_id = CallDataParser.get_client_id(call.data)
        OperatorCallbackHandlers.__show_client_files(call, bot, DIR_FOR_OTHER_FILES, client_id)

    @staticmethod
    def enter_menu_in_dialogue(call, bot):
        bot.edit_message_text(chat_id=call.message.chat.id,
                              message_id=call.message.message_id,
                              text='–ú–µ–Ω—é –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –∫–ª–∏–µ–Ω—Ç–æ–º', reply_markup=OperatorKeyboards.menu_in_dialogue())

    @staticmethod
    def upload_file_in_dialogue(call, bot):
        directory = redis_cache.get_selected_directory(call.from_user.id)
        logger.info(f'–í—ã–±—Ä–∞–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞: {directory}')
        dir_to_state = {
            DIR_FOR_TECHNICAL_TASKS: MyStates.get_technical_task_file_in_dialogue,
            DIR_FOR_COMMERCIAL_OFFERS: MyStates.get_commercial_offer_file_in_dialogue,
            DIR_FOR_REPORTS: MyStates.get_report_file_in_dialogue,
            DIR_FOR_OTHER_FILES: MyStates.get_other_file_in_dialogue
        }
        message = '–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª'
        state = dir_to_state.get(directory)
        bot.send_message(call.from_user.id, message)
        bot.set_state(call.from_user.id, state, call.from_user.id)

    @staticmethod
    def upload_file(call, bot):
        directory = redis_cache.get_selected_directory(call.from_user.id)
        logger.info(f'–í—ã–±—Ä–∞–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞: {directory}')
        dir_to_state = {
            DIR_FOR_TECHNICAL_TASKS: MyStates.get_technical_task_file,
            DIR_FOR_COMMERCIAL_OFFERS: MyStates.get_commercial_offer_file,
            DIR_FOR_REPORTS: MyStates.get_report_file,
            DIR_FOR_OTHER_FILES: MyStates.get_other_file
        }
        message = '–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª'
        state = dir_to_state.get(directory)
        bot.send_message(call.from_user.id, message)
        bot.set_state(call.from_user.id, state, call.from_user.id)

    @staticmethod
    def queue(call, bot):
        client_id = CallDataParser.get_client_id(call.data)
        redis_cache.move_client_to_first_place_in_queue(client_id)
        bot.send_message(call.message.chat.id, '–í—Å—Ç—É–ø–∏—Ç—å –≤ –¥–∏–∞–ª–æ–≥ —Å –∫–ª–∏–µ–Ω—Ç–æ–º ?',
                         reply_markup=OperatorKeyboards.customer_information(client_id))

    @staticmethod
    def change_question(call, bot):
        question_id = CallDataParser.get_question_id(call.data)
        question, default_answers = get_question_and_answers_from_db(question_id)
        if not default_answers:
            default_answers = '–ù–µ—Ç –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –æ—Ç–≤–µ—Ç–æ–≤'
        bot.set_state(call.from_user.id, OperatorStates.change_question)
        bot.add_data(call.from_user.id, question_id_for_change=question_id)
        bot.delete_message(call.message.chat.id, call.message.id)
        bot.send_message(call.message.chat.id, f'–í–æ–ø—Ä–æ—Å: {question}?\n\n–û—Ç–≤–µ—Ç—ã:\n{default_answers}\n'
                                               f'–í–ø–∏—à–∏—Ç–µ –≤–æ–ø—Ä–æ—Å –∏ –≤–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–≤–µ—Ç–æ–≤ —á–µ—Ä–µ–∑ |\n'
                                               f'–í–û–ü–†–û–° || –û–¢–í–ï–¢1| –û–¢–í–ï–¢2| –û–¢–í–ï–¢3\n\n'
                                               f'–ü—Ä–∏–º–µ—Ä:\n'
                                               f'–ö–∞–∫–æ–≤ —Ä–µ–π—Ç–∏–Ω–≥ –∫–æ–º–ø–∞–Ω–∏–∏ –≤ –†–æ—Å—Å–∏–∏ || 11| 34| –ù–µ –∑–Ω–∞—é',
                         reply_markup=OperatorKeyboards.change_question())

    @staticmethod
    def add_question(call, bot):
        bot.send_message(call.message.chat.id, '–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ä–∞–∑–¥–µ–ª–∞')

    # –î–∏–∞–ª–æ–≥ —Å –∫–ª–∏–µ–Ω—Ç–æ–º
    @staticmethod
    def enter_into_a_dialog(call, bot):
        operator = call.from_user.id
        client_id = CallDataParser.get_client_id(call.data)
        redis_cache.move_client_to_first_place_in_queue(client_id)
        redis_cache.set_operator_state(b'busy')
        logger.info(f'–û–ø–µ—Ä–∞—Ç–æ—Ä –≤—Å—Ç—É–ø–∏–ª –≤ –¥–∏–∞–ª–æ–≥ —Å –∫–ª–∏–µ–Ω—Ç–æ–º {client_id}')
        bot.set_state(client_id, MyStates.dialogue_with_operator)
        bot.set_state(operator, MyStates.dialogue_with_client)
        bot.delete_message(call.message.chat.id, call.message.id)
        bot.send_message(client_id, '–í—ã –≤—Å—Ç—É–ø–∏–ª–∏ –≤ –¥–∏–∞–ª–æ–≥ —Å –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–º\n')
        bot.send_message(operator, '–í—ã –≤—Å—Ç—É–ø–∏–ª–∏ –≤ –¥–∏–∞–ª–æ–≥ —Å –∫–ª–∏–µ–Ω—Ç–æ–º\n–ù–∞–ø–∏—à–∏—Ç–µ –µ–º—É:',
                         reply_markup=OperatorKeyboards.menu_in_dialogue())
        logger.info(
            f'–°–æ—Å—Ç–æ—è–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–∞ - {bot.get_state(client_id)}, –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ - {bot.get_state(operator)}')

    @staticmethod
    def client_info(call, bot):
        operator = call.from_user.id
        client_id = CallDataParser.get_client_id(call.data)
        bot.send_message(operator, '–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ',
                         reply_markup=OperatorKeyboards.customer_information(client_id))

    @staticmethod
    def left_dialog(call, bot):
        bot.delete_message(call.message.chat.id, call.message.id)
        client_id = redis_cache.get_first_client_and_delete_from_queue()
        if client_id is None:
            bot.send_message(OPERATOR_ID, f'–í—ã —É–∂–µ –≤—ã—Ö–æ–¥–∏–ª–∏ –∏–∑ —ç—Ç–æ–≥–æ –¥–∏–∞–ª–æ–≥–∞')
            return
        bot.delete_state(OPERATOR_ID, OPERATOR_ID)
        bot.delete_state(client_id, client_id)
        logger.info(f'–û–ø–µ—Ä–∞—Ç–æ—Ä –∑–∞–≤–µ—Ä—à–∏–ª –¥–∏–∞–ª–æ–≥ —Å –∫–ª–∏–µ–Ω—Ç–æ–º: {client_id}')
        logger.info(
            f'–°–æ—Å—Ç–æ—è–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–∞ - {bot.get_state(client_id, client_id)}, –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ - {bot.get_state(OPERATOR_ID, OPERATOR_ID)}')
        bot.send_message(OPERATOR_ID, f'–í—ã –≤—ã—à–ª–∏ –∏–∑ –¥–∏–∞–ª–æ–≥–∞!')
        next_client = redis_cache.get_first_client_from_queue()
        if next_client is None:
            redis_cache.set_operator_state(b'free')
            logger.info(f'–ó–∞–ø—Ä–æ—Å–æ–≤ –≤ –æ—á–µ—Ä–µ–¥–∏ –Ω–µ—Ç, —Å—Ç–∞—Ç—É—Å –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ –ø–µ—Ä–µ–≤–æ–¥ –≤ "—Å–≤–æ–±–æ–¥–µ–Ω" (free)')
            return
        logger.info(f'–ó–∞–ø—Ä–æ—Å –∫ –æ–ø–µ—Ä–∞—Ç–æ—Ä—É –Ω–∞ –¥–∏–∞–ª–æ–≥ –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞: {next_client}')
        logger.info(f'–ï—Å—Ç—å –∑–∞–ø—Ä–æ—Å—ã –≤ –æ—á–µ—Ä–µ–¥–∏, —Å—Ç–∞—Ç—É—Å –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ –ø–µ—Ä–µ–≤–µ–¥–µ–Ω –≤ "–∑–∞–Ω—è—Ç" (busy)')
        redis_cache.set_operator_state(b'busy')
        bot.send_message(OPERATOR_ID, f'üí¨–ó–∞–ø—Ä–æ—Å –Ω–∞ –¥–∏–∞–ª–æ–≥!üß®\n\n–û—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:\nID: {next_client}\n'
                         , reply_markup=OperatorKeyboards.customer_information(next_client))
